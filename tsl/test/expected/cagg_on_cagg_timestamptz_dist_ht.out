-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
------------------------------------
-- Set up a distributed environment
------------------------------------
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER
\set DATA_NODE_1 :TEST_DBNAME _1
\set DATA_NODE_2 :TEST_DBNAME _2
\set DATA_NODE_3 :TEST_DBNAME _3
\ir include/remote_exec.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE SCHEMA IF NOT EXISTS test;
psql:include/remote_exec.sql:5: NOTICE:  schema "test" already exists, skipping
GRANT USAGE ON SCHEMA test TO PUBLIC;
CREATE OR REPLACE FUNCTION test.remote_exec(srv_name name[], command text)
RETURNS VOID
AS :TSL_MODULE_PATHNAME, 'ts_remote_exec'
LANGUAGE C;
CREATE OR REPLACE FUNCTION test.remote_exec_get_result_strings(srv_name name[], command text)
RETURNS TABLE("table_record" CSTRING[])
AS :TSL_MODULE_PATHNAME, 'ts_remote_exec_get_result_strings'
LANGUAGE C;
SELECT (add_data_node (name, host => 'localhost', DATABASE => name)).*
FROM (VALUES (:'DATA_NODE_1'), (:'DATA_NODE_2'), (:'DATA_NODE_3')) v (name);
               node_name               |   host    | port  |               database                | node_created | database_created | extension_created 
---------------------------------------+-----------+-------+---------------------------------------+--------------+------------------+-------------------
 db_cagg_on_cagg_timestamptz_dist_ht_1 | localhost | 55432 | db_cagg_on_cagg_timestamptz_dist_ht_1 | t            | t                | t
 db_cagg_on_cagg_timestamptz_dist_ht_2 | localhost | 55432 | db_cagg_on_cagg_timestamptz_dist_ht_2 | t            | t                | t
 db_cagg_on_cagg_timestamptz_dist_ht_3 | localhost | 55432 | db_cagg_on_cagg_timestamptz_dist_ht_3 | t            | t                | t
(3 rows)

GRANT USAGE ON FOREIGN SERVER :DATA_NODE_1, :DATA_NODE_2, :DATA_NODE_3 TO PUBLIC;
-- PG15 requires this explicit GRANT on schema public
GRANT CREATE ON SCHEMA public TO :ROLE_DEFAULT_PERM_USER;
-- Setup test variables
\set IS_DISTRIBUTED TRUE
\set IS_TIME_DIMENSION TRUE
\set TIME_DIMENSION_DATATYPE TIMESTAMPTZ
\set CAGG_NAME_1ST_LEVEL conditions_summary_1_hourly
\set CAGG_NAME_2TH_LEVEL conditions_summary_2_daily
\set CAGG_NAME_3TH_LEVEL conditions_summary_3_weekly
\set BUCKET_WIDTH_1ST 'INTERVAL \'1 hour\''
\set BUCKET_WIDTH_2TH 'INTERVAL \'1 day\''
\set BUCKET_WIDTH_3TH 'INTERVAL \'1 week\''
SET timezone TO 'UTC';
--
-- Run common tests
--
\ir include/cagg_on_cagg_common.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\if :IS_DISTRIBUTED
\echo 'Running distributed hypertable tests'
Running distributed hypertable tests
\else
\echo 'Running local hypertable tests'
\endif
SET ROLE :ROLE_DEFAULT_PERM_USER;
-- CAGGs on CAGGs tests
CREATE TABLE conditions (
  time :TIME_DIMENSION_DATATYPE NOT NULL,
  temperature NUMERIC
);
\if :IS_DISTRIBUTED
  \if :IS_TIME_DIMENSION
    SELECT table_name FROM create_distributed_hypertable('conditions', 'time', replication_factor => 2);
 table_name 
------------
 conditions
(1 row)

  \else
    SELECT table_name FROM create_distributed_hypertable('conditions', 'time', chunk_time_interval => 10, replication_factor => 2);
  \endif
\else
  \if :IS_TIME_DIMENSION
    SELECT table_name FROM create_hypertable('conditions', 'time');
  \else
    SELECT table_name FROM create_hypertable('conditions', 'time', chunk_time_interval => 10);
  \endif
\endif
\if :IS_TIME_DIMENSION
  INSERT INTO conditions VALUES ('2022-01-01 00:00:00-00', 10);
  INSERT INTO conditions VALUES ('2022-01-01 01:00:00-00',  5);
  INSERT INTO conditions VALUES ('2022-01-02 01:00:00-00', 20);
\else
  CREATE OR REPLACE FUNCTION integer_now()
  RETURNS :TIME_DIMENSION_DATATYPE LANGUAGE SQL STABLE AS
  $$
    SELECT coalesce(max(time), 0)
    FROM conditions
  $$;
  \if :IS_DISTRIBUTED
    SELECT
      'CREATE OR REPLACE FUNCTION integer_now() RETURNS '||:'TIME_DIMENSION_DATATYPE'||' LANGUAGE SQL STABLE AS $$ SELECT coalesce(max(time), 0) FROM conditions $$;' AS "STMT"
      \gset
    CALL distributed_exec (:'STMT');
  \endif
  SELECT set_integer_now_func('conditions', 'integer_now');
  INSERT INTO conditions VALUES (1, 10);
  INSERT INTO conditions VALUES (2,  5);
  INSERT INTO conditions VALUES (5, 20);
\endif
-- CAGG on hypertable (1st level)
CREATE MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT
  time_bucket(:BUCKET_WIDTH_1ST, "time") AS bucket,
  SUM(temperature) AS temperature
FROM conditions
GROUP BY 1
WITH NO DATA;
-- CAGG on CAGG (2th level)
CREATE MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT
  time_bucket(:BUCKET_WIDTH_2TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_1ST_LEVEL
GROUP BY 1
WITH NO DATA;
-- CAGG on CAGG (3th level)
CREATE MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT
  time_bucket(:BUCKET_WIDTH_3TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_2TH_LEVEL
GROUP BY 1
WITH NO DATA;
-- No data because the CAGGs are just for materialized data
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

-- Turn CAGGs into Realtime
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=false);
-- Realtime data
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
(3 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
(2 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
(1 row)

-- Turn CAGGs into materialized only again
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=true);
-- Refresh all data
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- Materialized data
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
(3 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
(2 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
(1 row)

\if :IS_TIME_DIMENSION
-- Invalidate an old region
INSERT INTO conditions VALUES ('2022-01-01 01:00:00-00'::timestamptz, 2);
-- New region
INSERT INTO conditions VALUES ('2022-01-03 01:00:00-00'::timestamptz, 2);
\else
-- Invalidate an old region
INSERT INTO conditions VALUES (2,  2);
-- New region
INSERT INTO conditions VALUES (10, 2);
\endif
-- No changes
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
(3 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
(2 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
(1 row)

-- Turn CAGGs into Realtime
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=false);
-- Realtime changes, just new region
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
 Mon Jan 03 00:00:00 2022 UTC |           2
(3 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
 Mon Jan 03 00:00:00 2022 UTC |           2
(2 rows)

-- Turn CAGGs into materialized only again
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=true);
-- Refresh all data
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- All changes are materialized
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           7
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          17
 Sun Jan 02 00:00:00 2022 UTC |          20
 Mon Jan 03 00:00:00 2022 UTC |           2
(3 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          37
 Mon Jan 03 00:00:00 2022 UTC |           2
(2 rows)

-- TRUNCATE tests
TRUNCATE :CAGG_NAME_2TH_LEVEL;
-- This full refresh will remove all the data from the 3TH level cagg
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- Should return no rows
SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

-- If we have all the data in the bottom levels caggs we can rebuild
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- Now we have all the data
SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          17
 Sun Jan 02 00:00:00 2022 UTC |          20
 Mon Jan 03 00:00:00 2022 UTC |           2
(3 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          37
 Mon Jan 03 00:00:00 2022 UTC |           2
(2 rows)

-- DROP tests
\set ON_ERROR_STOP 0
-- should error because it depends of other CAGGs
DROP MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL;
psql:include/cagg_on_cagg_common.sql:178: ERROR:  cannot drop view conditions_summary_1_hourly because other objects depend on it
DROP MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_common.sql:179: ERROR:  cannot drop view conditions_summary_2_daily because other objects depend on it
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
psql:include/cagg_on_cagg_common.sql:180: NOTICE:  continuous aggregate "conditions_summary_1_hourly" is already up-to-date
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
psql:include/cagg_on_cagg_common.sql:181: NOTICE:  continuous aggregate "conditions_summary_2_daily" is already up-to-date
\set ON_ERROR_STOP 1
-- DROP the 3TH level CAGG don't affect others
DROP MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL;
psql:include/cagg_on_cagg_common.sql:185: NOTICE:  drop cascades to table _timescaledb_internal._hyper_4_4_chunk
\set ON_ERROR_STOP 0
-- should error because it was dropped
SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
psql:include/cagg_on_cagg_common.sql:188: ERROR:  relation "conditions_summary_3_weekly" does not exist at character 15
\set ON_ERROR_STOP 1
-- should work because dropping the top level CAGG
-- don't affect the down level CAGGs
TRUNCATE :CAGG_NAME_2TH_LEVEL,:CAGG_NAME_1ST_LEVEL;
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           7
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

-- DROP the 2TH level CAGG don't affect others
DROP MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_common.sql:199: NOTICE:  drop cascades to table _timescaledb_internal._hyper_3_3_chunk
\set ON_ERROR_STOP 0
-- should error because it was dropped
SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
psql:include/cagg_on_cagg_common.sql:202: ERROR:  relation "conditions_summary_2_daily" does not exist at character 15
\set ON_ERROR_STOP 1
-- should work because dropping the top level CAGG
-- don't affect the down level CAGGs
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           7
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

-- DROP the first CAGG should work
DROP MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL;
psql:include/cagg_on_cagg_common.sql:209: NOTICE:  drop cascades to table _timescaledb_internal._hyper_2_2_chunk
\set ON_ERROR_STOP 0
-- should error because it was dropped
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
psql:include/cagg_on_cagg_common.sql:212: ERROR:  relation "conditions_summary_1_hourly" does not exist at character 15
\set ON_ERROR_STOP 1
--
-- Validation test for variable bucket on top of fixed bucket
--
\set BUCKET_WIDTH_1ST 'INTERVAL \'1 month\''
\set BUCKET_WIDTH_2TH 'INTERVAL \'60 days\''
\set WARNING_MESSAGE '-- SHOULD ERROR because is not allowed variable-size bucket on top of fixed-size bucket'
\ir include/cagg_on_cagg_validations.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set CAGG_NAME_1ST_LEVEL conditions_summary_1
\set CAGG_NAME_2TH_LEVEL conditions_summary_2
--
-- CAGG on hypertable (1st level)
--
CREATE MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_1ST, "time") AS bucket,
  SUM(temperature) AS temperature
FROM conditions
GROUP BY 1
WITH NO DATA;
--
-- CAGG on CAGG (2th level)
--
\set VERBOSITY default
\set ON_ERROR_STOP 0
\echo :WARNING_MESSAGE
-- SHOULD ERROR because is not allowed variable-size bucket on top of fixed-size bucket
CREATE MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_2TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_1ST_LEVEL
GROUP BY 1
WITH NO DATA;
psql:include/cagg_on_cagg_validations.sql:33: ERROR:  cannot create continuous aggregate with fixed-width bucket on top of one using variable-width bucket
DETAIL:  Continuous aggregate with a fixed time bucket width (e.g. 61 days) cannot be created on top of one using variable time bucket width (e.g. 1 month).
The variance can lead to the fixed width one not being a multiple of the variable width one.
\set ON_ERROR_STOP 0
\set VERBOSITY terse
--
-- Cleanup
--
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_validations.sql:40: NOTICE:  materialized view "conditions_summary_2" does not exist, skipping
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_1ST_LEVEL;
--
-- Validation test for non-multiple bucket sizes
--
\set BUCKET_WIDTH_1ST 'INTERVAL \'2 hours\''
\set BUCKET_WIDTH_2TH 'INTERVAL \'3 hours\''
\set WARNING_MESSAGE '-- SHOULD ERROR because non-multiple bucket sizes'
\ir include/cagg_on_cagg_validations.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set CAGG_NAME_1ST_LEVEL conditions_summary_1
\set CAGG_NAME_2TH_LEVEL conditions_summary_2
--
-- CAGG on hypertable (1st level)
--
CREATE MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_1ST, "time") AS bucket,
  SUM(temperature) AS temperature
FROM conditions
GROUP BY 1
WITH NO DATA;
--
-- CAGG on CAGG (2th level)
--
\set VERBOSITY default
\set ON_ERROR_STOP 0
\echo :WARNING_MESSAGE
-- SHOULD ERROR because non-multiple bucket sizes
CREATE MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_2TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_1ST_LEVEL
GROUP BY 1
WITH NO DATA;
psql:include/cagg_on_cagg_validations.sql:33: ERROR:  cannot create continuous aggregate with incompatible bucket width
DETAIL:  Time bucket width of "public.conditions_summary_2" [@ 3 hours] should be multiple of the time bucket width of "public.conditions_summary_1" [@ 2 hours].
\set ON_ERROR_STOP 0
\set VERBOSITY terse
--
-- Cleanup
--
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_validations.sql:40: NOTICE:  materialized view "conditions_summary_2" does not exist, skipping
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_1ST_LEVEL;
--
-- Validation test for equal bucket sizes
--
\set BUCKET_WIDTH_1ST 'INTERVAL \'1 hour\''
\set BUCKET_WIDTH_2TH 'INTERVAL \'1 hour\''
\set WARNING_MESSAGE '-- SHOULD ERROR because new bucket should not be equal to previous'
\ir include/cagg_on_cagg_validations.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set CAGG_NAME_1ST_LEVEL conditions_summary_1
\set CAGG_NAME_2TH_LEVEL conditions_summary_2
--
-- CAGG on hypertable (1st level)
--
CREATE MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_1ST, "time") AS bucket,
  SUM(temperature) AS temperature
FROM conditions
GROUP BY 1
WITH NO DATA;
--
-- CAGG on CAGG (2th level)
--
\set VERBOSITY default
\set ON_ERROR_STOP 0
\echo :WARNING_MESSAGE
-- SHOULD ERROR because new bucket should not be equal to previous
CREATE MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_2TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_1ST_LEVEL
GROUP BY 1
WITH NO DATA;
psql:include/cagg_on_cagg_validations.sql:33: ERROR:  cannot create continuous aggregate with incompatible bucket width
DETAIL:  Time bucket width of "public.conditions_summary_2" [@ 1 hour] should be greater than the time bucket width of "public.conditions_summary_1" [@ 1 hour].
\set ON_ERROR_STOP 0
\set VERBOSITY terse
--
-- Cleanup
--
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_validations.sql:40: NOTICE:  materialized view "conditions_summary_2" does not exist, skipping
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_1ST_LEVEL;
--
-- Validation test for bucket size less than source
--
\set BUCKET_WIDTH_1ST 'INTERVAL \'2 hours\''
\set BUCKET_WIDTH_2TH 'INTERVAL \'1 hour\''
\set WARNING_MESSAGE '-- SHOULD ERROR because new bucket should be greater than previous'
\ir include/cagg_on_cagg_validations.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set CAGG_NAME_1ST_LEVEL conditions_summary_1
\set CAGG_NAME_2TH_LEVEL conditions_summary_2
--
-- CAGG on hypertable (1st level)
--
CREATE MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_1ST, "time") AS bucket,
  SUM(temperature) AS temperature
FROM conditions
GROUP BY 1
WITH NO DATA;
--
-- CAGG on CAGG (2th level)
--
\set VERBOSITY default
\set ON_ERROR_STOP 0
\echo :WARNING_MESSAGE
-- SHOULD ERROR because new bucket should be greater than previous
CREATE MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL
WITH (timescaledb.continuous) AS
SELECT
  time_bucket(:BUCKET_WIDTH_2TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_1ST_LEVEL
GROUP BY 1
WITH NO DATA;
psql:include/cagg_on_cagg_validations.sql:33: ERROR:  cannot create continuous aggregate with incompatible bucket width
DETAIL:  Time bucket width of "public.conditions_summary_2" [@ 1 hour] should be multiple of the time bucket width of "public.conditions_summary_1" [@ 2 hours].
\set ON_ERROR_STOP 0
\set VERBOSITY terse
--
-- Cleanup
--
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_validations.sql:40: NOTICE:  materialized view "conditions_summary_2" does not exist, skipping
DROP MATERIALIZED VIEW IF EXISTS :CAGG_NAME_1ST_LEVEL;
-- Cleanup
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER;
DROP DATABASE :DATA_NODE_1;
DROP DATABASE :DATA_NODE_2;
DROP DATABASE :DATA_NODE_3;
