-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- TEST1 count with integers
SHOW enable_partitionwise_aggregate;
 enable_partitionwise_aggregate 
--------------------------------
 off
(1 row)

SET enable_partitionwise_aggregate = on;
create table foo (a integer, b integer, c integer);
insert into foo values( 1 , 10 , 20);
insert into foo values( 1 , 11 , 20);
insert into foo values( 1 , 12 , 20);
insert into foo values( 1 , 13 , 20);
insert into foo values( 1 , 14 , 20);
insert into foo values( 2 , 14 , 20);
insert into foo values( 2 , 15 , 20);
insert into foo values( 2 , 16 , 20);
insert into foo values( 3 , 16 , 20);
create or replace view v1(a , partial)
as
 SELECT a, _timescaledb_functions.partialize_agg( count(b)) from foo group by a;
create table t1 as select * from v1;
select a, _timescaledb_functions.finalize_agg( 'count("any")', null, null, null, partial, cast('1' as int8) ) from t1
group by a order by a ;
 a | finalize_agg 
---+--------------
 1 |            5
 2 |            3
 3 |            1
(3 rows)

insert into t1 select * from t1;
select a, _timescaledb_functions.finalize_agg( 'count("any")', null, null, null, partial, cast('1' as int8) ) from t1
group by a order by a ;
 a | finalize_agg 
---+--------------
 1 |           10
 2 |            6
 3 |            2
(3 rows)

--TEST2 sum numeric and min on float--
drop table t1;
drop view v1;
drop table foo;
create table foo (a integer, b numeric , c float);
insert into foo values( 1 , 10 , 20);
insert into foo values( 1 , 20 , 19);
insert into foo values( 1 , 30 , 11.0);
insert into foo values( 1 , 40 , 200);
insert into foo values( 1 , 50 , -10);
insert into foo values( 2 , 10 , 20);
insert into foo values( 2 , 20 , 20);
insert into foo values( 2 , 30 , 20);
insert into foo values( 3 , 40 , 0);
create or replace view v1(a , partialb, partialminc)
as
 SELECT a,  _timescaledb_functions.partialize_agg( sum(b)) , _timescaledb_functions.partialize_agg( min(c)) from foo group by a;
create table t1 as select * from v1;
select a, _timescaledb_functions.finalize_agg( 'sum(numeric)', null, null, null, partialb, cast('1' as numeric) ) sumb, _timescaledb_functions.finalize_agg( 'min(double precision)', null, null, null, partialminc, cast('1' as float8) ) minc from t1 group by a order by a ;
 a | sumb | minc 
---+------+------
 1 |  150 |  -10
 2 |   60 |   20
 3 |   40 |    0
(3 rows)

insert into foo values( 3, 0, -1);
insert into foo values( 5, 40, 10);
insert into foo values( 5, 40, 0);
--note that rows for 3 get added all over again + new row
--sum aggfnoid 2114, min aggfnoid is 2136 oid  numeric is 1700
insert into t1 select * from v1 where ( a = 3 ) or a = 5;
select a, _timescaledb_functions.finalize_agg( 'sum(numeric)', null, null, null, partialb, cast('1' as numeric) ) sumb, _timescaledb_functions.finalize_agg( 'min(double precision)', null, null, null, partialminc, cast('1' as float8) ) minc from t1 group by a order by a ;
 a | sumb | minc 
---+------+------
 1 |  150 |  -10
 2 |   60 |   20
 3 |   80 |   -1
 5 |   80 |    0
(4 rows)

SET enable_partitionwise_aggregate = off;
--TEST3 sum with expressions
drop table t1;
drop view v1;
drop table foo;
create table foo (a integer, b numeric , c float);
insert into foo values( 1 , 10 , 20);
insert into foo values( 1 , 20 , 19);
insert into foo values( 1 , 30 , 11.0);
insert into foo values( 1 , 40 , 200);
insert into foo values( 1 , 50 , -10);
insert into foo values( 2 , 10 , 20);
insert into foo values( 2 , 20 , 20);
insert into foo values( 2 , 30 , 20);
insert into foo values( 3 , 40 , 0);
insert into foo values(10, NULL, NULL);
insert into foo values(11, NULL, NULL);
insert into foo values(11, NULL, NULL);
insert into foo values(12, NULL, NULL);
create or replace view v1(a , b, partialb, partialminc)
as
 SELECT a, b, _timescaledb_functions.partialize_agg( sum(b+c)) , _timescaledb_functions.partialize_agg( min(c)) from foo group by a, b ;
create table t1 as select * from v1;
insert into foo values( 3, 0, -1);
insert into foo values( 5, 40, 10);
insert into foo values( 5, 40, 0);
insert into foo values(12, 10, 20);
insert into t1 select * from v1 where ( a = 3 and b = 0 ) or a = 5 or (a = 12 and b = 10) ;
--results should match query: select a, sum(b+c), min(c) from foo group by a order by a;
--sum aggfnoid 2111 for float8, min aggfnoid is 2136 oid  numeric is 1700
select a, _timescaledb_functions.finalize_agg( 'sum(double precision)', null, null, null, partialb, null::float8 ) sumcd, _timescaledb_functions.finalize_agg( 'min(double precision)', null, null, null, partialminc, cast('1' as float8) ) minc from t1 group by a order by a ;
 a  | sumcd | minc 
----+-------+------
  1 |   390 |  -10
  2 |   120 |   20
  3 |    39 |   -1
  5 |    90 |    0
 10 |       |     
 11 |       |     
 12 |    30 |   20
(7 rows)

insert into t1 select * from v1;
select a, _timescaledb_functions.finalize_agg( 'sum(double precision)', null, null, null, partialb, null::float8 ) sumcd, _timescaledb_functions.finalize_agg( 'min(double precision)', null, null, null, partialminc, cast('1' as float8) ) minc from t1 group by a order by a ;
 a  | sumcd | minc 
----+-------+------
  1 |   780 |  -10
  2 |   240 |   20
  3 |    78 |   -1
  5 |   180 |    0
 10 |       |     
 11 |       |     
 12 |    60 |   20
(7 rows)

-- TEST4 with collation (text), NULLS and timestamp --
drop table t1;
drop view v1;
drop table foo;
create table foo (a integer, b numeric , c text, d timestamptz, e bigint);
insert into foo values( 1 , 10 , 'hello', '2010-01-01 09:00:00-08', 10);
insert into foo values( 1 , 20 , 'abc', '2010-01-02 09:00:00-08', 20);
insert into foo values( 1 , 30 , 'abcd',  '2010-01-03 09:00:00-08', 30);
insert into foo values( 1 , 40 , 'abcde', NULL, 40);
insert into foo values( 1 , 50 , NULL,  '2010-01-01 09:00:00-08', 50);
--group with all values for c and d same
insert into foo values( 2 , 10 ,  'hello', '2010-01-01 09:00:00-08', 10);
insert into foo values( 2 , 20 , 'hello', '2010-01-01 09:00:00-08', 20);
insert into foo values( 2 , 30 , 'hello', '2010-01-01 09:00:00-08', 30);
--group with all values for c and d NULL
insert into foo values( 3 , 40 , NULL, NULL, 40);
insert into foo values( 3 , 50 , NULL, NULL, 50);
insert into foo values(11, NULL, NULL, NULL, NULL);
insert into foo values(11, NULL, 'hello', '2010-01-02 09:00:00-05', NULL);
--group with all values for c and d NULL and later add non-null.
insert into foo values(12, NULL, NULL, NULL, NULL);
create or replace view v1(a , b, partialb, partialc, partiald, partiale, partialf)
as
 SELECT a, b, _timescaledb_functions.partialize_agg(sum(b))
 , _timescaledb_functions.partialize_agg(min(c))
 , _timescaledb_functions.partialize_agg(max(d))
 , _timescaledb_functions.partialize_agg(stddev(b))
 , _timescaledb_functions.partialize_agg(stddev(e)) from foo group by a, b ;
create table t1 as select * from v1;
--sum 2114, collid 0, min(text) 2145, collid 100, max(ts) 2127
insert into foo values(12, 10, 'hello', '2010-01-02 09:00:00-05', 10);
insert into t1 select * from v1 where  (a = 12 and b = 10) ;
--select a, sum(b), min(c) , max(d), stddev(b), stddev(e) from foo group by a order by a;
--results should match above query
CREATE OR REPLACE VIEW vfinal(a , sumb, minc, maxd, stddevb, stddeve)
AS
select a, _timescaledb_functions.finalize_agg( 'sum(numeric)', null, null, null, partialb, null::numeric ) sumb
, _timescaledb_functions.finalize_agg( 'min(text)', 'pg_catalog', 'default', null, partialc, null::text ) minc
, _timescaledb_functions.finalize_agg( 'max(timestamp with time zone)', null, null, null, partiald, null::timestamptz ) maxd
, _timescaledb_functions.finalize_agg( 'stddev(numeric)', null, null, null, partiale, null::numeric ) stddevb
, _timescaledb_functions.finalize_agg( 'stddev(int8)', null, null, null, partialf, null::numeric ) stddeve
from t1 group by a order by a ;
SELECT * FROM vfinal;
 a  | sumb | minc  |             maxd             |       stddevb       |       stddeve       
----+------+-------+------------------------------+---------------------+---------------------
  1 |  150 | abc   | Sun Jan 03 09:00:00 2010 PST | 15.8113883008418967 | 15.8113883008418967
  2 |   60 | hello | Fri Jan 01 09:00:00 2010 PST | 10.0000000000000000 | 10.0000000000000000
  3 |   90 |       |                              |  7.0710678118654752 |  7.0710678118654752
 11 |      | hello | Sat Jan 02 06:00:00 2010 PST |                     |                    
 12 |   10 | hello | Sat Jan 02 06:00:00 2010 PST |                     |                    
(5 rows)

CREATE TABLE vfinal_res AS SELECT * FROM vfinal;
-- overwrite partials with dumped binary values from PostrgeSQL 13 --
TRUNCATE TABLE t1;
\COPY t1 FROM data/partialize_finalize_data.csv WITH CSV HEADER
--repeat query to verify partial serialization sanitization works for versions PG >= 14
CREATE TABLE vfinal_dump_res AS SELECT * FROM vfinal;
ERROR:  insufficient data left in message
